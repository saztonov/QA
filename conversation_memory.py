"""Conversation memory module for managing chat history without media accumulation.

Stores last N text turns (without images/PDFs) and maintains a summary
that is updated by Flash model after each answer.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional


@dataclass
class Turn:
    """A single conversation turn (user or assistant)."""

    role: str  # "user" or "assistant"
    content: str  # Text content only, no media
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())


@dataclass
class ConversationMemory:
    """Manages conversation context without accumulating media.

    Attributes:
        max_turns: Maximum number of text turns to keep.
        turns: List of recent text turns.
        summary: Compressed summary of older conversation history.
        summary_updated_at: Timestamp of last summary update.
    """

    max_turns: int = 10
    turns: list[Turn] = field(default_factory=list)
    summary: str = ""
    summary_updated_at: Optional[str] = None

    def add_user_turn(self, content: str) -> None:
        """Add a user message to the conversation.

        Args:
            content: User's message text.
        """
        turn = Turn(role="user", content=content)
        self.turns.append(turn)
        self._trim_turns()

    def add_assistant_turn(self, content: str) -> None:
        """Add an assistant response to the conversation.

        Args:
            content: Assistant's response text.
        """
        turn = Turn(role="assistant", content=content)
        self.turns.append(turn)
        self._trim_turns()

    def _trim_turns(self) -> None:
        """Trim turns to max_turns, keeping most recent."""
        if len(self.turns) > self.max_turns:
            self.turns = self.turns[-self.max_turns:]

    def update_summary(self, new_summary: str) -> None:
        """Update the conversation summary.

        Args:
            new_summary: New summary text generated by summarizer.
        """
        self.summary = new_summary
        self.summary_updated_at = datetime.now().isoformat()

    def get_context_for_model(self) -> str:
        """Build context string for model prompts.

        Returns:
            Formatted context with summary and recent turns.
        """
        parts = []

        # Add summary if present
        if self.summary:
            parts.append(f"## Previous conversation summary:\n{self.summary}")

        # Add recent turns
        if self.turns:
            parts.append("## Recent messages:")
            for turn in self.turns:
                role_prefix = "User" if turn.role == "user" else "Assistant"
                parts.append(f"{role_prefix}: {turn.content}")

        return "\n\n".join(parts) if parts else ""

    def get_turns_for_summarization(self) -> list[Turn]:
        """Get turns that should be included in summarization.

        Returns:
            List of turns to summarize (typically all but most recent pair).
        """
        # Keep last 2 turns out of summary (current Q&A pair)
        if len(self.turns) > 2:
            return self.turns[:-2]
        return []

    def clear(self) -> None:
        """Clear all conversation history."""
        self.turns.clear()
        self.summary = ""
        self.summary_updated_at = None

    def get_stats(self) -> dict:
        """Get statistics about the conversation memory.

        Returns:
            Dictionary with memory statistics.
        """
        total_text_length = sum(len(t.content) for t in self.turns)
        return {
            "turns_count": len(self.turns),
            "max_turns": self.max_turns,
            "summary_length": len(self.summary),
            "total_text_length": total_text_length,
            "estimated_tokens": (total_text_length + len(self.summary)) // 3,
            "has_summary": bool(self.summary),
        }

    def should_update_summary(self) -> bool:
        """Check if summary should be updated.

        Returns:
            True if there are enough turns to summarize.
        """
        # Update summary when we have more than max_turns / 2 turns
        # and haven't summarized recently
        return len(self.turns) >= self.max_turns // 2 and len(self.get_turns_for_summarization()) > 0
